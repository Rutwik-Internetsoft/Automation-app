{"name": "test_split_cash_with_tip", "status": "broken", "statusDetails": {"message": "urllib3.exceptions.LocationParseError: Failed to parse: http://localhost:4723.ngrok.io/wd/hub/session", "trace": "url = 'http://localhost:4723.ngrok.io/wd/hub/session'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n>               host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\nE               AttributeError: 'NoneType' object has no attribute 'groups'\n\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\urllib3\\util\\url.py:423: AttributeError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.fixture(scope=\"session\")\n    def appium_driver():\n        \"\"\"Session-scoped Appium driver fixture.\"\"\"\n        driver_instance = AppiumDriver()\n>       driver = driver_instance.start_driver()\n\nconftest.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconftest.py:43: in start_driver\n    self.driver = webdriver.Remote(self.url, options=AppiumOptions().load_capabilities(self.caps))\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\appium\\webdriver\\webdriver.py:227: in __init__\n    super().__init__(\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:250: in __init__\n    self.start_session(capabilities)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\appium\\webdriver\\webdriver.py:319: in start_session\n    response = self.execute(RemoteCommand.NEW_SESSION, w3c_caps)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:427: in execute\n    response = self.command_executor.execute(driver_command, params)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:404: in execute\n    return self._request(command_info[0], url, body=data)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:428: in _request\n    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\urllib3\\_request_methods.py:143: in request\n    return self.request_encode_body(\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\urllib3\\_request_methods.py:278: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\urllib3\\poolmanager.py:420: in urlopen\n    u = parse_url(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://localhost:4723.ngrok.io/wd/hub/session'\n\n    def parse_url(url: str) -> Url:\n        \"\"\"\n        Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n        performed to parse incomplete urls. Fields not provided will be None.\n        This parser is RFC 3986 and RFC 6874 compliant.\n    \n        The parser logic and helper functions are based heavily on\n        work done in the ``rfc3986`` module.\n    \n        :param str url: URL to parse into a :class:`.Url` namedtuple.\n    \n        Partly backwards-compatible with :mod:`urllib.parse`.\n    \n        Example:\n    \n        .. code-block:: python\n    \n            import urllib3\n    \n            print( urllib3.util.parse_url('http://google.com/mail/'))\n            # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n    \n            print( urllib3.util.parse_url('google.com:80'))\n            # Url(scheme=None, host='google.com', port=80, path=None, ...)\n    \n            print( urllib3.util.parse_url('/foo?bar'))\n            # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n        \"\"\"\n        if not url:\n            # Empty\n            return Url()\n    \n        source_url = url\n        if not _SCHEME_RE.search(url):\n            url = \"//\" + url\n    \n        scheme: str | None\n        authority: str | None\n        auth: str | None\n        host: str | None\n        port: str | None\n        port_int: int | None\n        path: str | None\n        query: str | None\n        fragment: str | None\n    \n        try:\n            scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n            normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n    \n            if scheme:\n                scheme = scheme.lower()\n    \n            if authority:\n                auth, _, host_port = authority.rpartition(\"@\")\n                auth = auth or None\n                host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n                if auth and normalize_uri:\n                    auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n                if port == \"\":\n                    port = None\n            else:\n                auth, host, port = None, None, None\n    \n            if port is not None:\n                port_int = int(port)\n                if not (0 <= port_int <= 65535):\n                    raise LocationParseError(url)\n            else:\n                port_int = None\n    \n            host = _normalize_host(host, scheme)\n    \n            if normalize_uri and path:\n                path = _remove_path_dot_segments(path)\n                path = _encode_invalid_chars(path, _PATH_CHARS)\n            if normalize_uri and query:\n                query = _encode_invalid_chars(query, _QUERY_CHARS)\n            if normalize_uri and fragment:\n                fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n    \n        except (ValueError, AttributeError) as e:\n>           raise LocationParseError(source_url) from e\nE           urllib3.exceptions.LocationParseError: Failed to parse: http://localhost:4723.ngrok.io/wd/hub/session\n\n..\\miniconda3\\envs\\automation\\lib\\site-packages\\urllib3\\util\\url.py:449: LocationParseError"}, "start": 1741878419542, "stop": 1741878419542, "uuid": "a4929430-3e20-4da9-936a-3a38ffa713f5", "historyId": "7b9ae2b0fca2676088891fe79f562fc0", "testCaseId": "7b9ae2b0fca2676088891fe79f562fc0", "fullName": "suits.test_programs.test_split.TestSplitProgram#test_split_cash_with_tip", "labels": [{"name": "parentSuite", "value": "suits.test_programs"}, {"name": "suite", "value": "test_split"}, {"name": "subSuite", "value": "TestSplitProgram"}, {"name": "host", "value": "LAPTOP-KKMKONCC"}, {"name": "thread", "value": "1820-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "suits.test_programs.test_split"}]}